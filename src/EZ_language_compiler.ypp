%{
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <list>
#include <string>
#include <vector>
#include <cstdarg>

#include "../src/global.h"	 // we start from ../obj because it's important
#include "../src/hash_table/FunctionHashed.h"
#include "../src/hash_table/ScopeHashTable.h"
#include "../src/hash_table/VariableHashed.h"
#include "../src/main.cpp"	 // we start from ../obj because it's important
#include "../src/declarations/Class.h"
#include "../src/declarations/Function.h"
#include "../src/declarations/Procedure.h"
#include "../src/declarations/Variable.h"
#include "../src/modules/Node.h"
#include "../src/modules/TranslatedNode.h"
#include "../src/modules/BooleanExpression.h"
#include "../src/modules/BooleanValue.h"
#include "../src/modules/If.h"
#include "../src/modules/Else.h"
#include "../src/modules/For.h"
#include "../src/modules/While.h"
#include "../src/modules/Program.h" // Empty Node

#include "../src/global.h"


bool existing_parsing_error= false;

extern FILE* yyin;
using namespace std;

int yyparse (void);
extern "C" int yylex();
// extern YYLTYPE yylloc;
// extern "C" void yyerror(const char *s, ...);
extern "C" void yyerror(const std::string&);
extern "C" void yyprint(const std::string&);
extern int yylineno;

// Return the string value without quotation_marks
string delete_quote(string & str ){
  return str.substr(1,str.size()-2);
}

// Returns the argument value
string get_argument_value(string & str ){
  return str.substr(str.find_last_of("-")+1,str.size()-4);
}

extern ScopeHashTable symbolTable;

/* handle locations */
int yycolumn = 1;

#define YY_USER_ACTION yylloc.first_line = yyloc.last_line = yylineno; \
    yylloc.first_column = yycolumn; yylloc.last_column = yycolumn+yyleng-1; \
    yycolumn += yyleng;

#define YYERROR_VERBOSE
#define YY_USER_INIT yylloc.first_line=1;
#define USE(VALUE) /* empty */  

%}


// Tokens
%token<texte>	NUM_INTEGER     // Integer
%token<texte>	NUM_REAL			  // Real
%token<texte> NAME RETOUR STRING STRING_PARAM
%token COMMA DEGREE PERCENT SHARP DOUBLE_DOT SIMPLE_DOT QUOTE		// Caractères
%token<texte> TYPE_INTEGER TYPE_REAL TYPE_STRING TYPE_BOOLEAN     // variables typeVar
%token EQUALS NE LT LE GT GE PLUS MINUS MULT DIVISE
%token LEFT_PARENTHESIS RIGHT_PARENTHESIS LEFT_ACCOLADE RIGHT_ACCOLADE LEFT_BRACKET RIGHT_BRACKET FIN BACK_LINE	// Special Characters
%token<texte> CONST VARIABLE SHARED LOCAL GLOBAL IS ARE           // variables declaration
%token IMPORT INCLUDE LIBRARY EXTERN						                  // module import - c++ code
%token IF THEN ELSE   						  // if else 
%token WHEN CASE DEFAULT ENDWHEN	  // switch case ...
%token WHILE ENDWHILE							  // while .. do ...
%token REPEAT UNTIL ENDREPEAT 			// do .. while ...
%token FOR IN DO STEP 
%token RETURN FALSE TRUE            // words
%token FUNCTION PROCEDURE RETURNS	 	// functions
%token PRINT                        // Print text
%token OPERATOR                     // Overloading
%token BEGINN END						        // can not use 'BEGIN'
%token END_OF_FILE
%token CLASS PROGRAM DESTRUCT			  //class
%token ARGUMENTS AS							    // program arguments	
%token REGEX SEARCH MATCH 					// Regular expression

%token LENGTH TOUPPERCASE TOLOWERCASE
%token SUBSTRING SPLIT STRIP
%token REPLACE CONTAINS
%token FIND FINDFIRSTOF FINDLASTOF

%token ARRAY VECTOR LIST SET MAP OF

%token SIZE IS_EMPTY CLEAR FILL
%token RANDOMIZE COUNT MAX MIN SORT
%token SUM REMOVE RANGE PUT_FIRST PUT_LAST
%token REMOVE_LAST REMOVE_FIRST AVERAGE STORE
%token RESTORE FIRST LAST REMOVE_AT
%token PUT_AT INSERT EXIST

%left PLUS MINUS EQUALS
%left NE LT LE GT GE MULT DIVISE AND OR XOR NOT MOD POW ABS		// Operators

// Basic elements
%type<tree> ROOT
%type<tree> imports declaration_classes declarations_list declaration_variables declaration_methods
%type<vectVar> declaration_arguments param_args parameters methodParameters
// %type<vectString> 
%type<tree> argumentsList argumentsSeparated arguments
%type<tree> method affectation containerDeclaration function_call
%type<tree> map_declaration array_declaration vector_declaration list_declaration set_declaration
%type<tree> destruct printing // TODO overloading
%type<tree> if when while repeat for else
%type<tree> function procedure class import
%type<tree> statement return
%type<texte> assignmentOperator logicalOperator arithmeticOperator relationalOperator
%type<texte> type scope constancy string
%type<var>  simpleVariable variable variable_construct
%type<condExpr> conditionalExpression boolean
%type<transNode> expression basicExpression

// Non basic elements
%type<tree> function_string statement_sequence forBody affect streamedExpressions
%type<texte> names nbrOrName param_type
%type<texte> forDecl forType returnstype facultativeAssignment
%type<transNode> forStep forRangeStart forRangeEnd

// Parameters
// %define parse.trace

%start ROOT
%%

ROOT:
  PROGRAM NAME next_line imports declaration_arguments declaration_classes // 6 emt
  declarations_list PROCEDURE NAME BACK_LINE statement_sequence END endprocedure END_OF_FILE
	{
		Node* p_imports = $4;
		Program *racine = new Program(p_imports, $2);
    /* TODO add program arguments logic */
		Node* p_decl_class = $6;
		Node* p_decl_list = $7;
    
		Node* p_prog = $11;
    // $5 : parameters (vector<Variable*>)
    // @see main : procedure or function with int return ?
    Procedure* main= new Procedure(p_prog, "main", $5);

    p_decl_list->setRightSon(main);
		p_decl_class->setRightSon(p_decl_list);
    p_imports->setRightSon(p_decl_class);
    racine->setRightSon(p_imports);

		const std::string & translation= racine->translate();
    delete racine;

    // debug log
    debug("\n      TRANSLATION\n======================>>>>>\n"+ translation +
        "\n<<<<<======================\n        END TRANSLATION\n", AT);
    // output the translation in the output file (should result a valid cpp file)
    fprintf(yyout, "%s", translation.c_str());
    
		return 1; // No other file
    // return 0; // other file
	}
;

/* ******************
 *  PROGRAM MODULES *
 * ******************/

// import modules or libraries
imports:
  /* empty */
  { $$= new TranslatedNode(""); }
| imports import {
    /* TODO import logic */
    debugYacc("import", AT);
		TranslatedNode* importNode = (TranslatedNode *) $1;
    importNode->setRightSon($2);
    $$ = importNode;
  }
;

declaration_arguments:
  /* empty */
  { $$= vector<Variable*>(); }
| ARGUMENTS BACK_LINE param_args END endargument next_line {
    /* TODO arguements declaration logic */
    debugYacc("arguments declaration", AT);
    vector<Variable*> vars($3);
    $$ = vars;
  }
;

declaration_classes:
  /* empty */
  { $$= new TranslatedNode(""); }
| declaration_classes class BACK_LINE
	{
    debugYacc("class declared: "+ $1->getName(), AT);
		$1->addRightChild($2);
		$$ = $1;
	}
;

declarations_list:
  /* empty */
  { $$ = new TranslatedNode(""); }
| declaration_methods method declaration_variables
  {
    $1->addRightChild($2);
    $2->setRightSon($3);
    $$ = $1;
  }
| declaration_variables variable declaration_methods
  {
    $1->addRightChild($2);
    $2->setRightSon($3);
    $$ = $1;
  }
;

/* ******************
 *    SUBMODULES    *
 * ******************/

/* imports */
import:
  IMPORT NAME BACK_LINE {
    /* TODO import logic (name of module) */
    debugYacc("importation du module "+ $2, AT);
    TranslatedNode* trans_node= new TranslatedNode("#include \""+ $2 +"\"\n");
    $$= trans_node;
  }
| INCLUDE string BACK_LINE {
    /* TODO include import logic */
    debugYacc(" inclusion de la bibliothèque "+ $2, AT);
    TranslatedNode* trans_node= new TranslatedNode("#include "+ $2+ "\n");
    $$= trans_node;
  }
| LIBRARY string BACK_LINE {
    /* TODO library import logic */
    debugYacc(" inclusion de la LIBRARY "+ $2, AT);
    TranslatedNode* trans_node= new TranslatedNode("#include "+ $2+ "\n");
    $$= trans_node;
  }
;

/* declaration_arguments */
param_args:
  NAME IS param_type AS STRING_PARAM BACK_LINE { // ex: x is integer as "--x"
    cout << "parameter " << get_argument_value($5) << endl;
    vector<Variable*> var;
    TranslatedNode* string_param= new TranslatedNode($5);
    var.push_back(new Variable(nullptr, $1, $3, "local", string_param));
    $$= var;
  }
| NAME IS param_type AS STRING_PARAM BACK_LINE param_args {
  // TODO transform it into left recursive
    debugYacc("paramètre "+ get_argument_value($5), AT);
    TranslatedNode* string_param= new TranslatedNode($5);
    // Add parameter declaration to vector
    // TODO Variable should have right son, instead, of using Vector (replace nullptr) ?
    $7.push_back(new Variable(nullptr, $1, $3, "local", string_param));
    $$= $7;
  }
;

/* declarations_list */
declaration_variables:
  /* empty */
  { $$ = new TranslatedNode(""); }
| declaration_variables variable
	{
    $1->addRightChild($2);
	  $$ = $1;
	}
;

/* declarations_list */
declaration_methods:
  /* empty */
  { $$ = new TranslatedNode(""); }
| declaration_methods method BACK_LINE
	{
		$1->addRightChild($2);
		$$ = $1;
	}
;

method:
  function
	{
		$$ = $1;
	}
| procedure
	{
    $$ = $1;
	}
;

// Past arguments should be of only one of the following types: 
param_type:
  TYPE_INTEGER  { $$ = $1; }
| TYPE_REAL     { $$ = $1; } 
| TYPE_STRING   { $$ = $1; } 
;

/* declaration_classes */
class:
  CLASS NAME BACK_LINE begin statement_sequence END endclass
	{
    /* TODO class declaration logic */
		debugYacc("class declaration "+ $2, AT);
		// $$ = new Class();
	}
;

/* ********************
 *  GENERIC RECURSIVE *
 * ********************/

statement_sequence:
  /* empty */
  {
    debugYacc("last statement", AT);
    $$ = nullptr;
  }
| statement statement_sequence {
    debugYacc("statement: "+ $1->getName(), AT);
    // Add line jump at end of statement
    $1->addRightChild(new TranslatedNode(""));
    $1->addRightChild($2);
    $$ = $1;
  }
// @see if it is possible to use left recursion
// | statement_sequence statement {
//     debugYacc("statement: "+ $2->getName(), AT);
//     if ($1 == nullptr) $$ = $2;
//     else {
//       $1->addRightChild($2);
//       $$ = $1;
//     }
//   }
;

names:
  NAME              { $$ = $1; }
| names COMMA NAME  { $$ = $1 + ", " + $3; }
;

/* **********************
 *  METHODS DECLARATION *
 * **********************/

returnstype:
  RETURNS type
  {
    // $$= new Type($2);
  }
;

return:
  RETURN expression
  {
    TranslatedNode* returnWord= new TranslatedNode("return ");
    returnWord->setRightSon($2);
    $$ = returnWord;
  }
;

methodParameters:
  LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS {
    $$ = $2;
  }
;

// Parameters are variables that will used in a method, initiliazed with arguments
// that are passed as arguments at function call
parameters: 
  /* empty */ {
    vector<Variable*> v;
    $$ = v;
  }
| simpleVariable
 	{
    vector<Variable*> vect;
 		vect.push_back($1); // TODO use tree construction instead of vector
 		$$ = vect;
 	}
| simpleVariable COMMA parameters
 	{
 		$3.push_back($1);
 		$$ = $3;
 	}
// | NAME names ARE type { /* TODO parameters logic */ }
// TODO handle SHARED parameters
// | NAME names ARE SHARED type affect
// 	{
// 		cout << "Variable des variables1 "<< $1 << endl;
// 	}
;

// TODO function scope handling
function:
  FUNCTION NAME methodParameters returnstype BACK_LINE // { symbolTable.incScope(); }
  begin statement_sequence return BACK_LINE END endfunction
  {
		// symbolTable.decScope();
		debugYacc("fonction declaration: "+ $2, AT);
    // Right son of last instruction is return statement
    $7->setRightSon($8);

		Function *func = new Function($7,$2,$3,$4);
		$$ = func;
	}
// | FUNCTION NAME methodParameters IS EXTERN NAME
//   {
//     /* TODO extern function declaration logic @see hash table, but not no function creation ? */
//     cout << "declaration d'une fonction externe " << endl;
//   }
// | SHARED FUNCTION NAME methodParameters returnstype BACK_LINE // 6 elements {symbolTable.incScope(); }
//   begin statement_sequence return BACK_LINE END endfunction
//   {
//     /* TODO shared function declaration logic */
//     debugYacc("fonction declaration: "+ $3, AT);
//     $$ = new Function($10, nullptr, $3,$5,$7)
//   }
;

// TODO procedure scope handling
//    symbolTable.incScope();
// TODO Add procedure shared/not shared operator
procedure:
  PROCEDURE NAME methodParameters BACK_LINE statement_sequence END endprocedure
  {
    /* TODO procedure creation logic 1 */
    debugYacc("Procedure declaration : "+ $2, AT);
    Procedure *proc = new Procedure($5,$2,$3);
		$$ = proc;
		// symbolTable.decScope();
  }
  // TODO print overloading
// | PROCEDURE PRINT LEFT_PARENTHESIS RIGHT_PARENTHESIS BACK_LINE
//   begin statement_sequence END endprocedure
//   {
//     /* TODO print overloading logic 1 */
//     cout << "Surcharge de la methode d'affichage \"print\" "  << endl;
//     $$ = new Procedure(); // = f
// 		// symbolTable.decScope();
//   }
//     /* TODO shared procedure declaration logic */
// | SHARED procedureDecl BACK_LINE statement_sequence END endprocedure {
//     /* TODO procedure creation logic 2 */
//     debugYacc("Procedure creation ", AT);
//     // Procedure *f = new Procedure($1,$4,$4);
// 		$$ = nullptr; // = f
//   }
// | SHARED PROCEDURE PRINT LEFT_PARENTHESIS  RIGHT_PARENTHESIS BACK_LINE begin statement_sequence END endprocedure {
//     /* TODO print overloading logic 2 (factorize) */
//     cout << "Surcharge de la methode d'affichage \"print\" "  << endl;
//     $$ = nullptr;
//   }
;

/* ******************
 *   INSTRUCTIONS   *
 * ******************/

statement:
  BACK_LINE               { $$ = new TranslatedNode(""); }
| variable                { $$ = $1; }
| affectation             {
    TranslatedNode* semicolon= new TranslatedNode(";\n");
    $1->addRightChild(semicolon);
    $$ = $1;
  }
| containerDeclaration    { $$ = $1; }
| function_call           { $$ = $1; }
| destruct    { $$ = $1; }
| printing    { $$ = $1; }
// | overloading { $$ = $1; }
| if        { $$ = $1; }
| when      { $$ = $1; }
| while     { $$ = $1; }
| repeat    { $$ = $1; }
| for       { $$ = $1; }
;

containerDeclaration:
  map_declaration     { $$ = $1; }
| array_declaration   { $$ = $1; }
| vector_declaration  { $$ = $1; }
| list_declaration    { $$ = $1; }
| set_declaration     { $$ = $1; }
;

// TODO Avoid shift/reduce by factorising shared/not shared
variable:
  /* scope constancy */ simpleVariable BACK_LINE
  {
    debugYacc("Variable declaration: "+ $1->getName(), AT);
    // string scope_consistancy= $1+$2;
    // $3->setScope(scope_consistancy);
    $$ = $1;
  }
// | variable_construct
//   {
//     /* TODO variable construction logic (with class) */
//     debugYacc("variable construction (class)", AT);
//     $$ = $1;
//   }
;

/* ****************************
 *  Conditional Instructions  *
 * ****************************/
// If and loops
else:
  /* empty */
  { $$ = new TranslatedNode(""); }
| ELSE statement_sequence {
    $$ = new Else($2);
  }
;

if:
  IF conditionalExpression BACK_LINE THEN statement_sequence else END endif {
    debugYacc("If", AT);
    $$ = new If($5, $6, $2);
  }
;

when:
  WHEN conditionalExpression IS BACK_LINE whenbody whendefault END endwhen {
    /* TODO when logic */
    debugYacc("when .. case ..", AT);
  }
;

whenbody: /* whenbody can't be empty */
  CASE expression BACK_LINE statement_sequence END endcase {
    /* TODO whenbody logic 1 */
    cout << "case body" << endl;
  }
| CASE expression BACK_LINE statement_sequence END endcase whenbody {
    /* TODO whenbody logic 2 */
    cout << "case body" << endl;
  }
;

whendefault: /* May not be specified */
  /* empty */
| DEFAULT BACK_LINE statement_sequence END endcase {
    /* TODO whendefault logic 1 */
  }
;

while:
  WHILE conditionalExpression DO BACK_LINE statement_sequence END endwhile {
    debugYacc("WHILE .. DO ..", AT);
    $$ = new While($5, $2);
  }
;

repeat:
  REPEAT statement_sequence UNTIL BACK_LINE expression BACK_LINE END endrepeat {
    /* TODO repeat-until logic */
    debugYacc("REPEAT .. UNTIL ..", AT);
  }
;

/* for */
forDecl:
  // This should a name that is not already in current scope
  FOR NAME { $$= $2; }
;

forType:
  IS type { $$= $2; }
;

forRangeStart:
  IN expression { $$ = $2; }
;

forRangeEnd:
  DOUBLE_DOT expression { $$ = $2; }
;

forStep: // @see do step should be text or numeric_value ?
  STEP expression { $$= $2; }
;

forBody:
  DO BACK_LINE statement_sequence END endfor { $$ = $3; }
;

// TODO Add 'for' logics that handle going through containers
for:
  forDecl forRangeStart forRangeEnd forBody {
    debugYacc("FOR  IN .. ...", AT);
    TranslatedNode* simpleStep= new TranslatedNode("1");
    $$ = new For($1,$2,$3,simpleStep,$4);
  }
| forDecl forRangeStart forRangeEnd forStep forBody {
    debugYacc("FOR  IN .. STEP ...", AT);
    $$ = new For($1,$2,$3,$4,$5);
  }
| forDecl forType forRangeStart forRangeEnd forBody {
    /* TODO 'for a is TYPE in b .. c' logic */
    debugYacc("FOR type  IN .. ...", AT);
    TranslatedNode* simpleStep= new TranslatedNode("1");
    $$ = new For($1,$3,$4,simpleStep,$5,$2);
  }
| forDecl forType forRangeStart forRangeEnd forStep forBody {
    /* TODO 'for a is TYPE in b .. c step x' logic */
    debugYacc("FOR type  IN .. STEP ...", AT);
    $$ = new For($1,$3,$4,$5,$6,$2);
  }
;

/* ************************
 *  Complex Instructions  *
 * ************************/
// TODO function call
function_call:
  // NAME SIMPLE_DOT simple_function {}
  function_call SIMPLE_DOT simple_function {}
| simple_function { }
| NAME SIMPLE_DOT NAME { }
| function_string { $$ = $1;}
| containers_methods { }
// | function_regex { }
;

simple_function:
  // function without parameter
  NAME LEFT_PARENTHESIS RIGHT_PARENTHESIS {} 
  // function with parameter
| NAME LEFT_PARENTHESIS arguments RIGHT_PARENTHESIS {} 
;

arguments:
  /* empty */
  { $$ = new TranslatedNode(""); }
| expression { $$ = $1; }
| expression COMMA arguments {
    TranslatedNode* comma= new TranslatedNode(", ");
    $1->addRightChild(comma);
    comma->setRightSon($3);
    $$ = $1;
  }
;

// @see can be merged
argumentsList:
  /* empty */ // No argument
  { $$ = new TranslatedNode(""); }
  // TODO replace basicExpression by expression when validated
| facultativeAssignment basicExpression argumentsSeparated // One or more arguments
// arguments are separated by commas : they have a comma before, except the first one
  {
    // TODO Take assignment into account when passing argument (facultativeAssignment)
    $2->addRightChild($3);
    $$ = $2;
  }
;

argumentsSeparated:
  /* empty */
  { $$ = new TranslatedNode(""); }
| argumentsSeparated COMMA facultativeAssignment basicExpression
  {
    // TODO Take assignment into account when passing argument
    $1->addRightChild($4);
    $$ = $1;
  }
;

/* ************************
 *   Simple Instructions  *
 * ************************/
// TODO handle unary affectation operators (++, --, ...)*
affectation:
  NAME assignmentOperator expression {
    debugYacc("Affectation on "+ $1, AT);
    TranslatedNode* affect= new TranslatedNode($1 + $2 +" ");
    affect->setRightSon($3);
    $$ = affect;
  }
// | NAME SIMPLE_DOT NAME EQUALS expression { cout << "Affectation name.name " <<  endl; }
// | NAME PLUS PLUS { cout << "Affectation ++" <<  endl; }
// | NAME MINUS MINUS {  cout << "Affectation --" <<  endl; }
// | PLUS PLUS NAME  { cout << "++ Affectation " <<  endl; }
// | MINUS MINUS NAME  { cout << "-- Affectation " <<  endl;  }
;

destruct:
  // TODO reword destruction definition
  DESTRUCT BACK_LINE statement_sequence END enddestruct {
    /* TODO destructions logic */
    debugYacc("destructeur ", AT);
  }
;

streamedExpressions:
  /* empty */
  { $$ = new TranslatedNode(""); }
| streamedExpressions basicExpression {
    TranslatedNode* streamOperator= new TranslatedNode("<< ");

    $1->addRightChild(streamOperator);
    $1->addRightChild($2);
    $$ = $1;
  }
;

printing:
  PRINT streamedExpressions BACK_LINE {
    debugYacc("print "+ $2->translate(), AT);
    $$ = new TranslatedNode("std::cout"+ $2->translate() + "<< std::endl;\n", "Print (stdout)");
    delete $2;
  }
;

// overloading:
//   OPERATOR operator LEFT_PARENTHESIS NAME IS NAME RIGHT_PARENTHESIS RETURN type BACK_LINE begin statement_sequence END BACK_LINE {
//     /* TODO overloading operator logic */
//     cout << "operateur " <<  $2 << endl;
//   }
// ;

/* *******************
 *  GENERIC COMPLEX  *
 * ******************/

// one or several new lines
next_line:
  BACK_LINE BACK_LINE /* Nothing to do */
| next_line BACK_LINE /* Nothing to do */
;

// TODO handle parenthesis logic. Rework needs to be done on BooleanExpression class
conditionalExpression:
  boolean { $$ = $1; }
  // NAME should be boolean
| NAME    {
    debugYacc("BooleanExpression from variable "+ $1, AT);
    $$ = new BooleanExpression($1);
  }
// | LEFT_PARENTHESIS conditionalExpression RIGHT_PARENTHESIS {
//     TranslatedNode* parenthCond= new TranslatedNode("("+ $2->translate() +")");
//     delete $2;
//     $$ = parenthCond;
//   }
| conditionalExpression logicalOperator conditionalExpression {
    BooleanExpression* expr= new BooleanExpression($2,$1,$3);
    $$ = expr;
  }
| NOT conditionalExpression {
    debugYacc("Negation", AT);
    BooleanExpression* negation= new BooleanExpression("!", $2);
    $$ = negation;
  }
| expression relationalOperator expression {
    debugYacc("conditionalExpression by comparison", AT);
    BooleanExpression* comparison= new BooleanExpression($2,$1,$3);

    $$ = comparison;
  }
;

expression:
  /* TODO check that there is no other operators*/
  expression arithmeticOperator expression {
    debugYacc("Operation between two expressions", AT);
    TranslatedNode* arithOperator= new TranslatedNode(" "+ $2 +" ");

    $1->addRightChild(arithOperator);
    arithOperator->setRightSon($3);
    $$ = $1;
  }
| LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {
    TranslatedNode* parenthExpr= new TranslatedNode("("+ $2->translate() +")");
    delete $2;
    $$ = parenthExpr;
  }
| basicExpression {
    debugYacc("expression from basicExpression", AT);
    $$ = $1;
  }
;

/* TODO single_expressions logic. What's the goal ? */
// single_expression:
//   PLUS single_expression { /* $$ = new Variable(); */ }
// | NOT single_expression { /* $$ = new Variable(); */ }
// | single_expression XOR single_expression { /* $$ = new Variable(); */ }
// | single_expression MOD single_expression { /* $$ = new Variable(); */ }
// | single_expression POW single_expression { /* $$ = new Variable(); */ }
// // | ABS single_expression { /* $$ = new Variable(); */ } // @see how to handle absolute
// | argument  { $$ = $1; }
// ;

simpleVariable:
  NAME IS type affect
  {
    debugYacc("Variable : "+ $1, AT);
    VariableHashed v($1,$3); // @see if same thing if function parameters
    symbolTable.addElement(v);
    $$ = new Variable(nullptr, $1,$3,"local",$4,false);
  }
// | NAME names ARE type affect BACK_LINE
// 	{
//     /* TODO multiple variables declaration logic 1 */
// 		debugYacc("Variable declaration: "+ $1, AT);
// 	}
//     // TODO Handle SHARED
// | NAME IS SHARED type affect BACK_LINE
// 	{
// 		VariableHashed v($1,$3);
// 		symbolTable.addElement(v);
// 		// $$ = new Variable($2,$4,$1,true);
// 	}
//     // TODO Handle SHARED
// | NAME names ARE SHARED type BACK_LINE
// 	{
//     /* TODO multiple variables declaration logic 2 */
// 		debugYacc("  Variable des variables  avec portee "+ $1, AT);
// 	}
;

scope:
  /* empty */
  { $$ = "local"; }
| LOCAL   { $$ = "local";}
| GLOBAL  { $$ = "global";}
;

constancy:
  /* empty */
  { $$ = ""; }
| CONST { $$ = "const"; }
;

variable_construct:
  NAME IS NAME {}  // ex: c is Maclasse
| NAME IS NAME LEFT_PARENTHESIS argumentsList RIGHT_PARENTHESIS {} // c is MaClass(val1,va2)
| NAME IS NAME LEFT_PARENTHESIS RIGHT_PARENTHESIS {} // No arguments to construction
;

/* ******************
 *  GENERIC SIMPLE  *
 * ******************/

// zero or some new lines
lineend:
  END_OF_FILE
| BACK_LINE /* Nothing to do */
;

begin:
  BACK_LINE         { }
| BEGINN BACK_LINE  { }
;

// @see can it just be a translated Node (variable name don't change) or a Node (Var or value)
// TODO affect logic
affect:
  /* empty */
  { $$ = new TranslatedNode(""); }
| EQUALS basicExpression {
    debugYacc("Affectation value: "+ $2->translate(), AT);
    $$ = $2;
  }
// | EQUALS expression { $$ = $2; } // TODO use expression ?
// | EQUALS string   { $$ = $2; }
;

type:
  TYPE_INTEGER  { $$ = "int"; }
| TYPE_REAL     { $$ = "real"; }
| TYPE_STRING   { $$ = "string"; }
| TYPE_BOOLEAN  { $$ = "bool"; }
;

boolean:
  TRUE  { $$ = new BooleanValue(true); }
| FALSE { $$ = new BooleanValue(false); }
;

basicExpression:
  string      { $$ = new TranslatedNode($1); }
| boolean     { $$ = new TranslatedNode($1->translate()); delete $1; }
| NUM_INTEGER { $$ = new TranslatedNode($1); }
| NUM_REAL    { $$ = new TranslatedNode($1); }
| NAME        { $$ = new TranslatedNode($1); /* @see if variable must be retrieved from name */ }
;

// TODO facultativeAssignment logic
facultativeAssignment:
  /* empty */
  { $$ = ""; } // ex: c is myClass(var1, var2)
| NAME EQUALS   { $$ = $1; } // ex: p is Person(name="name")
;

assignmentOperator:
  EQUALS { $$ = "="; }
| arithmeticOperator EQUALS { $$ = $1 + "="; }
;

arithmeticOperator:
  PLUS    { $$ = "+"; }
| MINUS   { $$ = "-"; }
| MULT    { $$ = "*"; }
| DIVISE  { $$ = "/"; }
| MOD     { $$ = "%"; }
;

// NOT is a logical operator, but it is unary, not binary. Must be handle separatly
// @see if we use operator or TranslatedNode
logicalOperator:
  AND { $$ = "&&"; }
| OR { $$ = "||"; }
;

relationalOperator:
  EQUALS EQUALS { $$ = "=="; }
| NE  { $$ = "!="; }
| LT  { $$ = "<"; }
| LE  { $$ = "<="; }
| GT  { $$ = ">"; }
| GE  { $$ = ">="; }
;

nbrOrName:
  NUM_INTEGER { /* $$ = Integer(to_string($1)); */ }
| NUM_REAL    { /* $$ = Real($1); */ }
| NAME        { /* $$ = String($1); */ }
;

string:
  STRING  { $$ = $1; }
;

/* *********************
 * FACULATIVE END TAGS *
 * *********************/

endclass:
  lineend
| CLASS lineend {}
;

endfunction:
  lineend
| FUNCTION lineend {}
;

endprocedure:
  lineend
| PROCEDURE lineend {}
;

endif:
  lineend
| IF lineend {}
;

endwhen:
  lineend
| WHEN lineend {}
;

endcase:
  lineend
| CASE lineend {}
;

endwhile:
  lineend
| WHILE lineend {}
;

endfor:
  lineend
| FOR lineend {}
;

endrepeat:
  lineend
| REPEAT lineend {}
;

enddestruct:
  lineend
| DESTRUCT lineend {}
;

endargument:
  lineend
| ARGUMENTS lineend {}
;


/* ************
 *    OTHER   *
 * ************/
// 		---------------------------------------------------------------------
// 		---------------------------------------------------------------------

/* else_body:
   ELSE BACK_LINE statement_sequence   { cout << "else " << endl; }
|  ELSE BACK_LINE statement_sequence  else_body  { cout << "else " << endl;}
;*/

//    -----------------------------REGEX METHODS-----------------------------------------
// function_regex:
//   NAME SIMPLE_DOT MATCH LEFT_PARENTHESIS strOrName RIGHT_PARENTHESIS { cout << "regular expression MATCH " << endl ;}
// | NAME SIMPLE_DOT SEARCH LEFT_PARENTHESIS strOrName COMMA strOrName RIGHT_PARENTHESIS { cout << "regular expression SEARCH " << endl ;}
// | NAME SIMPLE_DOT REPLACE LEFT_PARENTHESIS strOrName COMMA strOrName RIGHT_PARENTHESIS { cout << "regular expression REPLACE " << endl ;}
// ;

//    -----------------------------STRING METHODS----------------------------------------
function_string: 
  NAME SIMPLE_DOT LENGTH LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("lENGTH() called \n"); }
| NAME SIMPLE_DOT TOUPPERCASE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("toUpperCase() called \n"); }
| NAME SIMPLE_DOT TOLOWERCASE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("toLowerCase() called \n"); }
| NAME SIMPLE_DOT SUBSTRING LEFT_PARENTHESIS NUM_INTEGER RIGHT_PARENTHESIS { printf("SUBSTRING(int) called \n"); }
| NAME SIMPLE_DOT SUBSTRING LEFT_PARENTHESIS NAME RIGHT_PARENTHESIS { printf("SUBSTRING(int) called \n"); }
| NAME SIMPLE_DOT SUBSTRING LEFT_PARENTHESIS NUM_INTEGER COMMA NUM_INTEGER RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME SIMPLE_DOT SUBSTRING LEFT_PARENTHESIS NAME COMMA NUM_INTEGER RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME SIMPLE_DOT SUBSTRING LEFT_PARENTHESIS NUM_INTEGER COMMA NAME RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME SIMPLE_DOT SUBSTRING LEFT_PARENTHESIS NAME COMMA NAME RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| NAME SIMPLE_DOT SPLIT LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("SPLIT(\"str\") called \n"); }
| NAME SIMPLE_DOT STRIP LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("strip() called \n"); }
| NAME SIMPLE_DOT STRIP LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("strip(\"str\") called \n"); }
| NAME SIMPLE_DOT REPLACE LEFT_PARENTHESIS STRING COMMA STRING RIGHT_PARENTHESIS { printf("replace(\"str\",\"str\") called \n"); }
| NAME SIMPLE_DOT CONTAINS LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("contain(\"str\") called \n"); }
| NAME SIMPLE_DOT FIND LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("find(\"str\") called \n"); }
| NAME SIMPLE_DOT FINDFIRSTOF LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("findFirstOF(\"str\") called \n"); }
| NAME SIMPLE_DOT FINDLASTOF LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("findFirstOF(\"str\") called \n"); }
;


//    -----------------------------array Déclaration----------------------------------------
array_declaration:
scope NAME IS ARRAY LEFT_BRACKET NUM_INTEGER DOUBLE_DOT NUM_INTEGER RIGHT_BRACKET OF type { printf("array declaration with lower and upper bound \n"); }
| scope NAME IS ARRAY LEFT_BRACKET NUM_INTEGER DOUBLE_DOT NAME RIGHT_BRACKET OF type { printf("array declaration with lower and upper bound \n"); }
| scope NAME IS ARRAY LEFT_BRACKET NAME DOUBLE_DOT NUM_INTEGER RIGHT_BRACKET OF type { printf("array declaration with lower and upper bound\n"); }
| scope NAME IS ARRAY LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type { printf("array declaration with size \n"); }
| scope NAME IS ARRAY LEFT_BRACKET NAME RIGHT_BRACKET OF type { printf("array declaration with size \n"); }
| scope NAME IS ARRAY LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type EQUALS LEFT_ACCOLADE names RIGHT_ACCOLADE { printf("array declaration  with initializer list \n"); }
| scope NAME IS ARRAY LEFT_BRACKET NAME RIGHT_BRACKET OF type EQUALS LEFT_ACCOLADE names RIGHT_ACCOLADE {printf("array declaration with size with initializer list \n"); }
;

//    -----------------------------vector declaration----------------------------------------
vector_declaration: 
scope NAME IS VECTOR OF type { printf("vector declaration  \n"); }
| scope NAME IS VECTOR LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type { printf("vector declaration with size \n"); }
| scope NAME IS VECTOR LEFT_BRACKET NAME RIGHT_BRACKET OF type { printf("vector declaration with size \n"); }
| scope NAME IS VECTOR OF type EQUALS LEFT_ACCOLADE names RIGHT_ACCOLADE { printf("vector declaration with initializer list \n"); }
;

//    -----------------------------list declaration----------------------------------------
list_declaration: 
scope NAME IS LIST OF type { printf("list declaration  \n"); }
| scope NAME IS LIST OF type EQUALS LEFT_ACCOLADE names RIGHT_ACCOLADE { printf("list declaration with initializer list \n"); }
;

//    -----------------------------set declaration----------------------------------------
set_declaration: 
scope NAME IS SET OF type { printf("set declaration  \n"); }
| scope NAME IS SET LEFT_BRACKET NUM_INTEGER RIGHT_BRACKET OF type { printf("set declaration with size \n"); }
| scope NAME IS SET LEFT_BRACKET NAME RIGHT_BRACKET OF type { printf("set declaration with size \n"); }
| scope NAME IS SET OF type EQUALS LEFT_ACCOLADE names RIGHT_ACCOLADE { printf("set declaration with initializer list \n"); }
;

//    -----------------------------map declaration----------------------------------------
map_declaration: 
scope NAME IS MAP OF LT type COMMA type GT { printf("map declaration  \n"); }
| map_declaration EQUALS LEFT_ACCOLADE names RIGHT_ACCOLADE { printf("map declaration with initializer list \n"); }
;

//    ---------------------------------------------------------------------------------------
//    -----------------------------Containers methods---------------------------------------
//    ---------------------------------------------------------------------------------------

containers_methods : 
  NAME SIMPLE_DOT SIZE LEFT_PARENTHESIS RIGHT_PARENTHESIS      { printf("utilisation de la méthode size  \n"); }
| NAME SIMPLE_DOT IS_EMPTY LEFT_PARENTHESIS RIGHT_PARENTHESIS  { printf("utilisation de la méthode size  \n"); }
| NAME SIMPLE_DOT CLEAR LEFT_PARENTHESIS RIGHT_PARENTHESIS     { printf("utilisation de la méthode size  \n"); }
| NAME SIMPLE_DOT PRINT LEFT_PARENTHESIS RIGHT_PARENTHESIS     { printf("utilisation de la méthode toString  \n"); }
| NAME SIMPLE_DOT FILL LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("fill(value) called \n"); }
| NAME SIMPLE_DOT RANDOMIZE LEFT_PARENTHESIS nbrOrName COMMA nbrOrName RIGHT_PARENTHESIS { printf("randomize(min,max) called \n"); }
| NAME SIMPLE_DOT MAX LEFT_PARENTHESIS RIGHT_PARENTHESIS           { printf("MAX() called \n"); }
| NAME SIMPLE_DOT MAX LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("MAX(attr) called \n"); }
| NAME SIMPLE_DOT MIN LEFT_PARENTHESIS RIGHT_PARENTHESIS           { printf("MIN() called \n"); }
| NAME SIMPLE_DOT MIN LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("MIN(attr) called \n"); }
| NAME SIMPLE_DOT SORT LEFT_PARENTHESIS RIGHT_PARENTHESIS            { printf("SORT() called \n"); }
| NAME SIMPLE_DOT SORT LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS  { printf("SORT(attr) called \n"); }
| NAME SIMPLE_DOT SUM LEFT_PARENTHESIS RIGHT_PARENTHESIS             { printf("SUM() called \n"); }
| NAME SIMPLE_DOT SUM LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS   { printf("SUM(attr) called \n"); }
| NAME SIMPLE_DOT COUNT LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS             { printf("COUNT(val) called \n"); }
| NAME SIMPLE_DOT COUNT LEFT_PARENTHESIS NAME COMMA nbrOrName RIGHT_PARENTHESIS  { printf("COUNT(attr,val) called \n"); }
| NAME SIMPLE_DOT REMOVE LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS  { printf("remove(val) called \n"); }
| NAME SIMPLE_DOT RANGE LEFT_PARENTHESIS RIGHT_PARENTHESIS             { printf("range() called \n"); }
| NAME SIMPLE_DOT FIND LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS            { printf("find(val) called \n"); }
| NAME SIMPLE_DOT FIND LEFT_PARENTHESIS NAME COMMA nbrOrName RIGHT_PARENTHESIS { printf("find(attr,val) called \n"); }
| NAME SIMPLE_DOT PUT_FIRST LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("PUT_FIRST(elem) called \n"); }
| NAME SIMPLE_DOT PUT_LAST LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS  { printf("PUT_Last(elem) called \n"); }
| NAME SIMPLE_DOT REMOVE_LAST LEFT_PARENTHESIS RIGHT_PARENTHESIS   { printf("remove_Last() called \n"); }
| NAME SIMPLE_DOT REMOVE_FIRST LEFT_PARENTHESIS RIGHT_PARENTHESIS  { printf("remove_Last() called \n"); }
| NAME SIMPLE_DOT AVERAGE LEFT_PARENTHESIS RIGHT_PARENTHESIS           { printf("average() called \n"); }
| NAME SIMPLE_DOT AVERAGE LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS { printf("average(attr) called \n"); }
| NAME SIMPLE_DOT STORE LEFT_PARENTHESIS NAME RIGHT_PARENTHESIS    { printf("STORE(val) called \n"); }
| NAME SIMPLE_DOT RESTORE LEFT_PARENTHESIS NAME RIGHT_PARENTHESIS  { printf("RESTORE(val) called \n"); }
| NAME SIMPLE_DOT FIRST LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("first() called \n"); }
| NAME SIMPLE_DOT LAST LEFT_PARENTHESIS RIGHT_PARENTHESIS  { printf("last() called \n"); }
| NAME SIMPLE_DOT REMOVE_AT LEFT_PARENTHESIS NUM_INTEGER RIGHT_PARENTHESIS               { printf("REMOVE_AT(pos) called \n"); }
| NAME SIMPLE_DOT PUT_AT LEFT_PARENTHESIS NUM_INTEGER COMMA nbrOrName RIGHT_PARENTHESIS  { printf("put_at(pos, val) called \n"); }
| NAME SIMPLE_DOT INSERT LEFT_PARENTHESIS RIGHT_PARENTHESIS                              { printf("insert() called \n"); }
| NAME SIMPLE_DOT INSERT LEFT_PARENTHESIS nbrOrName COMMA nbrOrName RIGHT_PARENTHESIS    { printf("insert(key,val called \n"); }
| NAME SIMPLE_DOT EXIST LEFT_PARENTHESIS nbrOrName RIGHT_PARENTHESIS                     { printf("insert() called \n"); }
;


%%

void yyerror(const std::string& mess){
    std::cerr << "Error found at line " << yylineno << " :  "<< mess << std::endl;
    existing_parsing_error= true;
}

// int
// yylex (void)
// {
//   int c;

//   /* Skip white space.  */
//   while ((c = getchar ()) == ' ' || c == '\t')
//     ++yylloc.last_column;

//   /* Step.  */
//   yylloc.first_line = yylloc.last_line;
//   yylloc.first_column = yylloc.last_column;

//   /* Process numbers.  */
//   if (isdigit (c))
//     {
//       yylval = c - '0';
//       ++yylloc.last_column;
//       while (isdigit (c = getchar ()))
//         {
//           ++yylloc.last_column;
//           yylval = yylval * 10 + c - '0';
//         }
//       ungetc (c, stdin);
//       return NUM;
//     }

//   /* Return end-of-input.  */
//   if (c == EOF)
//     return 0;

//   /* Return a single char, and update location.  */
//   if (c == '\n')
//     {
//       ++yylloc.last_line;
//       yylloc.last_column = 0;
//     }
//   else
//     ++yylloc.last_column;
//   return c;
// }


// void yyerror(const char *s, ...){
//   va_list ap;
//   va_start(ap, s);

//   if(yylloc.first_line)
//     fprintf(stderr, "%s:%d.%d-%d.%d: error: ", /*yylloc.filename,*/ yylloc.first_line, 
//      yylloc.first_column, yylloc.last_line, yylloc.last_column);
//   vfprintf(stderr, s, ap);
//   fprintf(stderr, "\n");
// }

void yyprint(const std::string& mess){
    std::cout << "[l" << yylineno << "] "<<mess  << std::endl;
}
