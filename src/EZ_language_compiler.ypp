%{
#include <stdio.h>
#include <cstdlib>
#include <cstdarg>
#include <iostream>
#include <list>
#include <string>
#include <vector>

#include "../src/global.h"	 // we start from ../obj because it's important
#include "../src/hash_table/ClassHashed.h"
#include "../src/hash_table/FunctionHashed.h"
#include "../src/hash_table/ScopeHashTable.h"
#include "../src/hash_table/VariableHashed.h"
#include "../src/main.cpp"	 // we start from ../obj because it's important
#include "../src/modules/Node.h"
#include "../src/modules/EmptyNode.h"

// Modules
#include "../src/declarations/Array.h"
#include "../src/declarations/Class.h"
#include "../src/declarations/Container.h"
#include "../src/declarations/Function.h"
#include "../src/declarations/Import.h"
#include "../src/declarations/List.h"
#include "../src/declarations/Main.h"
#include "../src/declarations/Map.h"
#include "../src/declarations/Parameter.h"
#include "../src/declarations/Procedure.h"
#include "../src/declarations/Set.h"
#include "../src/declarations/Variable.h"
#include "../src/declarations/Vector.h"
#include "../src/modules/ArrayAccess.h"
#include "../src/modules/BooleanExpression.h"
#include "../src/modules/BooleanValue.h"
#include "../src/modules/Operator.h"
#include "../src/modules/Program.h"
#include "../src/modules/TranslatedNode.h"
#include "../src/instructions/Affectation.h"
#include "../src/instructions/If.h"
#include "../src/instructions/Else.h"
#include "../src/instructions/For.h"
#include "../src/instructions/FunctionCall.h"
#include "../src/instructions/Repeat.h"
#include "../src/instructions/While.h"

#include "../src/global.h"

bool existing_parsing_error= false;

extern std::string INPUT_FUNC_NAME;
extern FILE* yyin;

using namespace std;

int yyparse (void);
extern "C" int yylex();
// extern YYLTYPE yylloc;
// extern "C" void yyerror(const char *s, ...);
extern "C" void yyerror(const std::string&);
extern "C" void yyprint(const std::string&);
extern int yylineno;

// Return the string value without quotation_marks
string delete_quote(string & str ){
  return str.substr(1,str.size()-2);
}

// Returns the argument value
string get_argument_value(string & str ){
  return str.substr(str.find_last_of("-")+1,str.size()-4);
}

extern ScopeHashTable symbolTable;

/* handle locations */
int yycolumn = 1;

#define YY_USER_ACTION yylloc.first_line = yyloc.last_line = yylineno; \
    yylloc.first_column = yycolumn; yylloc.last_column = yycolumn+yyleng-1; \
    yycolumn += yyleng;

#define YYERROR_VERBOSE
#define YYDEBUG 1
#define YY_USER_INIT yylloc.first_line=1;
#define USE(VALUE) /* empty */

%}

// Tokens
%token<text> NUM_INTEGER     // Integer
%token<text> NUM_REAL			  // Real
%token<text> NAME RETOUR STRING STRING_PARAM ANYTHING CODE_TEXT
%token COMMA DEGREE PERCENT SHARP DOUBLE_DOT SIMPLE_DOT QUOTE		// Caractères
%token<text> TYPE_INTEGER TYPE_REAL TYPE_STRING TYPE_BOOLEAN     // variables typeVar
%token EQUALS NE LT LE GT GE PLUS MINUS MULT DIVISE
%token LEFT_PARENTHESIS RIGHT_PARENTHESIS LEFT_ACCOLADE RIGHT_ACCOLADE LEFT_BRACKET RIGHT_BRACKET FIN BACK_LINE	// Special Characters
%token<text> CONST VARIABLE SHARED LOCAL GLOBAL IS ARE           // variables declaration
%token IMPORT INCLUDE LIBRARY EXTERN						                  // module import - c++ code
%token IF THEN ELSE   						  // if else 
%token WHEN CASE DEFAULT ENDWHEN	  // switch case ...
%token WHILE ENDWHILE							  // while .. do ...
%token REPEAT UNTIL ENDREPEAT 			// do .. while ...functions
%token FOR IN DO STEP 
%token RETURN FALSE TRUE            // words
%token FUNCTION PROCEDURE RETURNS	 	// functions
%token PRINT INPUT                  // Print and get input text 
%token OPERATOR                     // Overloading
%token BEGINN END PROGRAM      // can not use 'BEGIN'
%token END_OF_FILE
%token CLASS  DESTRUCT			        //class
%token PARAMETERS AS							  // program arguments	
%token REGEX SEARCH MATCH 					// Regular expression

%token LENGTH TOUPPERCASE TOLOWERCASE
%token SUBSTRING SPLIT STRIP
%token REPLACE CONTAINS
%token FIND FINDFIRSTOF FINDLASTOF

%token ARRAY VECTOR LIST SET MAP OF

%token SIZE IS_EMPTY CLEAR FILL
%token RANDOMIZE COUNT MAX MIN SORT
%token SUM REMOVE RANGE PUT_FIRST PUT_LAST
%token REMOVE_LAST REMOVE_FIRST AVERAGE STORE
%token RESTORE FIRST LAST REMOVE_AT
%token PUT_AT INSERT EXIST

%left PLUS MINUS EQUALS
%left NE LT LE GT GE MULT DIVISE AND OR XOR NOT MOD POW ABS		// Operators

// Basic elements
%type<tree> program
%type<tree> program.imports program.classes program.variables program.methods
%type<declaration> method.parameters
%type<param> program.parameters parameter_sequence parameter .parameters parameters
%type<array> arrayDeclaration
%type<cont> stdContainerDeclaration
%type<tree> destruct printing input // TODO overloading
%type<tree> while repeat for // when
%type<affectation> affectation
%type<ifNode> if
%type<elseNode> .else
%type<returnNode> function.return
%type<text> function.returnedType
%type<classNode> class
%type<declaration> declaration
%type<genericCont> containerDeclaration
%type<var>  simpleVariable variable variable_construct
%type<opeNode> assignmentOperator arithmeticOperator logicalOperator relationalOperator equalityOperator
%type<functionCall> simpleFunction functionCall functionCallNoParenthesis
%type<transNode> code
%type<method> method function procedure
%type<expr> arguments .argumentsList argumentElement
%type<tree> statement import
%type<text> type .scope // TODO constancy
%type<condExpr> conditionalExpression boolean
%type<expr> expression stringExpressions stringExpression integerExpression numericExpression basicExpressions basicExpression
%type<expr> runtimeValue varValue numeric number real integer string
%type<arrayAccess> containerAccess

// Non basic elements
%type<text> objectDotOperator
%type<tree> function_string statement_sequence .statement_sequence .streamedExpressions .argumentsSeparated
%type<expr> .affect
%type<var> class.variables
%type<method> class.methods
%type<tree> for.body
// %type<text> names // Add multiple variables declarations in one instruction
%type<text> for.decl for.type var.decl array.decl array.type class.decl
%type<cont> container.decl
%type<expr> simpleFunction.arguments streamedExpressions.element
%type<expr> for.step for.rangeStart for.rangeEnd .container.affectation container.affectation .container.initSize

// Parameters
// %define parse.trace
%debug
%error-verbose

%start program
%%

// baseROOT:
//   PROGRAM NAME next_line imports declaration_arguments program.classes program.variables // 7 emt
//   {

//   }
// ;

program:
  PROGRAM NAME next_line program.imports .jump program.parameters program.classes program.variables // 8 emt
  // baseROOT
  program.methods NAME BACK_LINE .statement_sequence END lineend END_OF_FILE
	{
    if ($10 != $2) {
        cerr<< "Program and main procedure should have same names"<< endl;
        exit(EXIT_FAILURE);
    }

    // Symbols naming
    Node* p_imports = $4;
    CommonVar* p_decl_parameters = $6;
    Node* p_decl_classes = $7;
    Node* p_decl_vars = $8;
    Node* p_decl_methods = $9;
    Node* p_prog_instr = $12;
    /* TODO add program parameters logic */
    Main* main= new Main(p_decl_parameters, p_prog_instr);

    // Progam declaration and nodes relations
    Program *racine = new Program($2, p_imports, p_decl_classes);
    
    p_decl_classes->addRightChild(p_decl_vars);
    p_decl_vars->addRightChild(p_decl_methods);
    p_decl_methods->addRightChild(main);

    // Translation
    const std::string & translation= racine->translate();
    delete racine;

    // debug log
    info("\n      TRANSLATION\n======================>>>>>\n"+ translation +
        "\n<<<<<======================\n        END TRANSLATION\n", AT);
    // output the translation in the output file (should result a valid cpp file)
    fprintf(yyout, "%s", translation.c_str());
    
    return 1; // No other file
    // return 0; // other file
  }
  // | baseROOT NAME BACK_LINE statement_sequence END lineend END_OF_FILE
;

.jump:
  /* empty */
| .jump BACK_LINE
;

// one or several new lines
next_line:
  BACK_LINE BACK_LINE /* Nothing to do */
| next_line BACK_LINE /* Nothing to do */
;

/* ******************
 *  PROGRAM MODULES *
 * ******************/

// import modules or libraries
program.imports:
  .jump
  { $$= new EmptyNode; }
| program.imports import {
    /* TODO import logic */
    debug("import", AT);
    $1->addRightChild($2);
    $$ = $1;
  }
;

// @see in foc there is: [...] AS STRING_PARAM BACK_LINE { // ex: x is integer as "--x0"
program.parameters:
  /* empty */
  { $$ = nullptr; }
| PARAMETERS BACK_LINE parameter_sequence END endparameters {
    /* TODO arguements declaration logic */
    debug("parameters declaration", AT);
    $$ = $3;
  }
;

program.classes:
  .jump
  { $$= new TranslatedNode("\n"); }
| program.classes class
	{
    debug("class declared: "+ $1->getDetails(), AT);
		$1->addRightChild($2);
		$$ = $1;
	}
;

// declarations_list:
//   // /* empty */
//   // { $$ = new EmptyNode; }
// program.variables program.methods
//   {
//     $1->addRightChild($2);
//     // $2->addRightChild($3);
//     $$ = $1;
//   }
// // | program.methods method program.variables
// //   {
// //     $1->addRightChild($2);
// //     $2->addRightChild($3);
// //     $$ = $1;
// //   }
// ;

/* ******************
 *    SUBMODULES    *
 * ******************/

/* imports */
import:
  IMPORT NAME BACK_LINE {
    /* TODO import logic: check file existance and compile it (with its cpp) */
    debugYacc("importation du module "+ $2, AT);
    Import* trans_node= new Import($2, LOCAL_FILE);
    $$= trans_node;
  }
  // For C++ system file include
| INCLUDE STRING BACK_LINE {
    debugYacc(" inclusion de la bibliothèque "+ $2, AT);
    std::string import_name= replace($2, "\"", "");
    Import* trans_node= new Import(import_name, EXTERNAL_LIBRARY);
    $$= trans_node;
  }
;

/* declarations_list */
program.variables:
  /* empty */
  { $$ = new EmptyNode; }
| program.variables BACK_LINE variable
	{
    $1->addRightChild($3);
	  $$ = $1;
	}
;

/* declarations_list */
program.methods:
  /* empty */
  { $$ = new EmptyNode; }
| program.methods method .jump
	{
		$1->addRightChild($2);
		$$ = $1;
	}
;

parameter_sequence:
  /* empty */
  {
    debug("no more parameters", AT);
    $$ = nullptr;
  }
| parameter_sequence parameter .jump {
    debug("parameter : "+ $2->getName(), AT);
    if ($1 != nullptr){
      $1->addRightChild($2);
      $$ = $1;
    }
    else $$ = $2;
  }
;

/* *************
 *  STATEMENTS *
 * *************/

.statement_sequence:
  /* empty */
// @see if it is possible not to use EmptyNode, but nullptr
  {
    debug("no more statements", AT);
    $$ = new EmptyNode;
  }
| statement_sequence { $$ = $1; }
;

statement_sequence:
  statement { $$ = $1; }
| statement_sequence statement {
    debug("statement: "+ $2->getName(), AT);
    
    $1->addRightChild($2);
    $$ = $1;
  }
;

/* **********************
 *  CLASS DECLARATION *
 * **********************/

/* program.classes */
class:
  class.decl class.variables .jump class.methods class.end
  {
    /* TODO class hashed logic */
    debugYacc("class declaration "+ $1, AT);
    ClassHashed * hash_class= new ClassHashed($1);

    $$ = new Class(hash_class, $2, $4);
  }
| class.decl class.methods .jump class.variables class.end
  {
    /* TODO class hashed logic */
    debugYacc("class declaration "+ $1, AT);
    ClassHashed * hash_class= new ClassHashed($1);

    $$ = new Class(hash_class, $4, $2);
  }
;

class.decl:
  CLASS NAME BACK_LINE begin { $$ = $2; }
;

class.variables:
  /* empty */
  {
    debugYacc("no more variable", AT);
    $$ = nullptr;
  }
| class.variables variable {
    debugYacc("variable : "+ $2->getName(), AT);
    if ($1 != nullptr) {
      $1->addRightChild($2);
      $$ = $1;
    }
    else $$ = $2;
  }
;

class.methods:
  /* empty */
  {
    debug("no more method", AT);
    $$ = nullptr;
  }
| class.methods method {
    debug("method: "+ $2->getName(), AT);
    if ($1 != nullptr) {
      $1->addRightChild($2);
      $$ = $1;
    }
    else $$ = $2;
  }
;

class.end:
  .jump END .jump endclass
;

/* **********************
 *  METHODS DECLARATION *
 * **********************/

method:
  function  { $$ = $1; }
| procedure { $$ = $1; }
;

// TODO function scope handling
function:
  FUNCTION NAME method.parameters function.returnedType BACK_LINE // { symbolTable.incScope(); }
  begin statement_sequence function.return BACK_LINE END endfunction
  {
		// symbolTable.decScope();
		debugYacc("fonction declaration: "+ $2, AT);
    // Right son of last instruction is return statement
    $7->addRightChild($8);

		Function *func = new Function($2,$3,$7,$4);
		$$ = func;
	}
// | FUNCTION NAME method.parameters IS EXTERN NAME
//   {
//     /* TODO extern function declaration logic @see hash table, but not no function creation ? */
//     cout << "declaration d'une fonction externe " << endl;
//   }
// | SHARED FUNCTION NAME method.parameters function.returnedType BACK_LINE // 6 elements {symbolTable.incScope(); }
//   begin statement_sequence return BACK_LINE END endfunction
//   {
//     /* TODO shared function declaration logic */
//     debugYacc("fonction declaration: "+ $3, AT);
//     $$ = new Function($10, nullptr, $3,$5,$7)
//   }
;

// TODO procedure scope handling
//    symbolTable.incScope();
// TODO Add procedure shared/not shared operator
procedure:
  PROCEDURE NAME method.parameters BACK_LINE statement_sequence END endprocedure
  {
    /* TODO procedure creation logic 1 */
    debugYacc("Procedure declaration : "+ $2, AT);
    Procedure *proc = new Procedure($2,$3,$5);
		$$ = proc;
		// symbolTable.decScope();
  }
  // TODO print overloading
// | PROCEDURE PRINT LEFT_PARENTHESIS RIGHT_PARENTHESIS BACK_LINE
//   begin statement_sequence END endprocedure
//   {
//     /* TODO print overloading logic 1 */
//     cout << "Surcharge de la methode d'affichage \"print\" "  << endl;
//     $$ = new Procedure(); // = f
// 		// symbolTable.decScope();
//   }
//     /* TODO shared procedure declaration logic */
// | SHARED procedureDecl BACK_LINE statement_sequence END endprocedure {
//     /* TODO procedure creation logic 2 */
//     debugYacc("Procedure creation ", AT);
//     // Procedure *f = new Procedure($1,$4,$4);
// 		$$ = nullptr; // = f
//   }
// | SHARED PROCEDURE PRINT LEFT_PARENTHESIS  RIGHT_PARENTHESIS BACK_LINE begin statement_sequence END endprocedure {
//     /* TODO print overloading logic 2 (factorize) */
//     cout << "Surcharge de la methode d'affichage \"print\" "  << endl;
//     $$ = nullptr;
//   }
;

function.returnedType:
  RETURNS type
  {
    // TODO function.returnedType logic
    // $$= new Type($2);
  }
;

function.return:
  RETURN expression
  {
    Return* returnWord= new Return($2);
    $$ = returnWord;
  }
;

method.parameters:
  LEFT_PARENTHESIS .parameters RIGHT_PARENTHESIS { $$ = $2; }
;

// Parameters are variables that will used in a method, initialiazed with values
// that are passed as arguments at function call
.parameters: 
  /* empty */
  { $$ = nullptr; }
| parameters 
 	{ $$ = $1; }
;

parameters:
  parameter
 	{ $$ = $1; }
| parameter COMMA parameters
 	{
    $1->addRightChild($3);
    $$ = $1;
 	}
// | names ARE type { /* TODO parameters logic */ }
// TODO handle SHARED parameters
// | names ARE SHARED type affect
// 	{
// 		cout << "Variable des variables1 "<< $1 << endl;
// 	}

/* ******************
 *   INSTRUCTIONS   *
 * ******************/

statement:
  BACK_LINE { $$ = new EmptyNode; }
| if        { $$ = $1; }
| while     { $$ = $1; }
| repeat    { $$ = $1; }
| for       { $$ = $1; }
| declaration           { $$ = $1; }
| affectation           { $$ = $1; }
| functionCall          { $$ = $1; }
| functionCallNoParenthesis { $$ = $1; }
| function_string       { $$ = $1;}
| destruct  { $$ = $1; }
| printing  { $$ = $1; }
| input     { $$ = $1; }
// | overloading { $$ = $1; }
| code      { $$ = $1; }
// TODO add when implementation ?
// | when      { $$ = $1; }
;

/*  Conditional Instructions  *
 *        If and loops        */

.else:
  /* empty */
  { $$ = nullptr; }
| ELSE statement_sequence {
    $$ = new Else($2);
  }
;

if:
  IF conditionalExpression BACK_LINE THEN statement_sequence .else END endif {
    debugYacc("If", AT);
    $$ = new If($5, $6, $2);
  }
;

// when:
//   WHEN conditionalExpression IS BACK_LINE whenbody whendefault END endwhen {
//     /* TODO when logic */
//     debugYacc("when .. case ..", AT);
//   }
// ;

// when.body: /* whenbody can't be empty */
//   CASE expression BACK_LINE statement_sequence END endcase {
//     /* TODO whenbody logic 1 */
//     cout << "case body" << endl;
//   }
// | CASE expression BACK_LINE statement_sequence END endcase whenbody {
//     /* TODO whenbody logic 2 */
//     cout << "case body" << endl;
//   }
// ;

// when.default: /* May not be specified */
//   /* empty */
// | DEFAULT BACK_LINE statement_sequence END endcase {
//     /* TODO whendefault logic 1 */
//   }
// ;

while:
  WHILE conditionalExpression DO BACK_LINE statement_sequence END endwhile {
    debugYacc("WHILE .. DO ..", AT);
    $$ = new While($2, $5);
  }
;

repeat:
  REPEAT BACK_LINE statement_sequence UNTIL conditionalExpression lineend {
    debugYacc("REPEAT .. UNTIL ..", AT);
    $$ = new Repeat($3, $5);
  }
;

/* for */
for.decl:
  // This should a name that is not already in current scope
  FOR NAME { $$= $2; }
;

for.type:
  IS type { $$= $2; }
;

for.rangeStart:
  IN integerExpression { $$ = $2; }
;

for.rangeEnd:
  DOUBLE_DOT integerExpression { $$ = $2; }
;

for.step: // @see do step should be text or numeric_value ?
  STEP integerExpression { $$= $2; }
;

for.body:
  DO BACK_LINE .statement_sequence END endfor { $$ = $3; }
;

// TODO Add 'for' logics that handle going through containers
for:
  for.decl for.rangeStart for.rangeEnd for.body {
    debugYacc("FOR  IN .. ...", AT);
    TranslatedNode* simpleStep= new TranslatedNode("1");
    $$ = new For($1,$2,$3,simpleStep,$4);
  }
| for.decl for.rangeStart for.rangeEnd for.step for.body {
    debugYacc("FOR  IN .. STEP ...", AT);
    $$ = new For($1,$2,$3,$4,$5);
  }
| for.decl for.type for.rangeStart for.rangeEnd for.body {
    /* TODO 'for a is TYPE in b .. c' logic */
    debugYacc("FOR type  IN .. ...", AT);
    TranslatedNode* simpleStep= new TranslatedNode("1");
    $$ = new For($1,$3,$4,simpleStep,$5,$2);
  }
| for.decl for.type for.rangeStart for.rangeEnd for.step for.body {
    /* TODO 'for a is TYPE in b .. c step x' logic */
    debugYacc("FOR type  IN .. STEP ...", AT);
    $$ = new For($1,$3,$4,$5,$6,$2);
  }
;

/*    Other Instructions    *
 * *************************/

declaration:
  variable             { $$ = $1; }
| containerDeclaration { $$ = $1; }
//| class                 { $$ = $1; }
;

// TODO Add other container declarations
containerDeclaration:
  arrayDeclaration        { $$ = $1; }
| stdContainerDeclaration { $$ = $1; }
// | map_declaration     { $$ = $1; }
// | list_declaration    { $$ = $1; }
// | set_declaration     { $$ = $1; }
;

// TODO Avoid shift/reduce by factorising shared/not shared
variable:
  /* scope constancy */ simpleVariable BACK_LINE
  {
    debug("Variable declaration: "+ $1->getName(), AT);
    // string scope_consistancy= $1+$2;
    // $3->setScope(scope_consistancy);
    $$ = $1;
  }
| variable_construct
  {
    debug("variable construction (class)", AT);
    $$ = $1;
  }
;

// TODO handle unary affectation operators (++, --, ...)*
affectation:
  NAME assignmentOperator expression {
    debugYacc("Affectation on "+ $1, AT);
    Affectation* affect= new Affectation($1, $2, $3);
    $$ = affect;
  }
// | NAME SIMPLE_DOT NAME EQUALS expression { cout << "Affectation name.name " <<  endl; }
// | NAME PLUS PLUS { cout << "Affectation ++" <<  endl; }
// | NAME MINUS MINUS {  cout << "Affectation --" <<  endl; }
// | PLUS PLUS NAME  { cout << "++ Affectation " <<  endl; }
// | MINUS MINUS NAME  { cout << "-- Affectation " <<  endl;  }
;

destruct:
  // TODO reword destruction definition
  DESTRUCT BACK_LINE statement_sequence END enddestruct {
    /* TODO destructions logic */
    debugYacc("destructeur (not implemented yet)", AT);
  }
;

// TODO create a function call cpp class, for input, string funcs and generics (and printing)
input:
  INPUT IN NAME BACK_LINE {
    debugYacc("input in "+ $3, AT);
    $$ = new TranslatedNode(INPUT_FUNC_NAME +"(&"+ $3 + ");\n", "Get input (stdin)");
  }
;

printing:
  PRINT .streamedExpressions BACK_LINE {
    debugYacc("print "+ $2->translate(), AT);
    $$ = new TranslatedNode("std::cout"+ $2->translate() + "<< std::endl;\n", "Print (stdout)");
    delete $2;
  }
;

// overloading:
//   OPERATOR operator LEFT_PARENTHESIS  var.decl NAME RIGHT_PARENTHESIS RETURN type BACK_LINE begin statement_sequence END BACK_LINE {
//     /* TODO overloading operator logic */
//     cout << "operateur " <<  $2 << endl;
//   }
// ;

// code:
//   CODE begin ANYTHING endcode {
//     TranslatedNode* cpp_instructions= new TranslatedNode($3);
//     $$ = cpp_instructions;
//   }
// ;

code:
  CODE_TEXT END lineend {
    TranslatedNode* cpp_instructions= new TranslatedNode($1+"\n");
    $$ = cpp_instructions;
  }
;

// TODO function call
functionCall:
  // objectDotOperator simpleFunction {}
  functionCall SIMPLE_DOT simpleFunction {
    $1->addRightChild($3);
    $$ = $1;
  }
| objectDotOperator simpleFunction {
    $2->addObject($1);
    $$ = $2;
  }
| simpleFunction {
    $$ = $1;
  }
// | objectDotOperator NAME { } attributeAccess ? (in classAccess ?
// | containers_methods { } // TODO implement containers methods
// | function_regex { }
;

  // At least one argument when no parenthesis
functionCallNoParenthesis:
  NAME .argumentsList {
    debugYacc("Call of function (no parenthesis) '"+ $1 +"'", AT);

    $$ = new FunctionCall($1, $2);
  }
;

simpleFunction.arguments:
  arguments { $$ = $1; }
;

simpleFunction:
  // function call without parenthesis
  NAME simpleFunction.arguments {
    debugYacc("Call of function '"+ $1 +"'", AT);

    $$ = new FunctionCall($1, $2);
  }
// @see Should it be "object" instead of NAME ?
;

/* *******************
 *    GENERIC BLOCS  *
 * ******************/

arguments:
  LEFT_PARENTHESIS .argumentsList RIGHT_PARENTHESIS
  {
    debug("Arguments (w/ parenthesis)", AT);
    $$ = $2;
  }
;

// arguments are separated by commas : they have a comma before, except the first one
.argumentsList:
  /* empty */ // No argument
  { $$ = new EmptyNode; }
| argumentElement .argumentsSeparated {// One or more arguments
    $1->addRightChild($2);
    $$ = $1;
  }
;

.argumentsSeparated:
  /* empty */
  { $$ = new EmptyNode; }
| .argumentsSeparated COMMA argumentElement
  {
    TranslatedNode* comma= new TranslatedNode(", ", $3);

    $1->addRightChild(comma);
    $$ = $1;
  }
;

argumentElement:
  expression {
    $$ = $1;
  }
;

runtimeValue:
  functionCall {
    $1->setAsNotInstruction();
    $$ = $1;
  }
| containerAccess { $$ = $1; }
| varValue { $$ = $1; }
;

// TODO add constancy to parameter
parameter:
  var.decl type .affect
  {
    debugYacc("Parameter : "+ $1, AT);
    // VariableHashed v($1,$2); //@see if variable hashed for method declaration parameters
    // symbolTable.addElement(v);
    $$ = new Parameter($1,$2,$3);
  }
| containerDeclaration { $$ = $1; }
;

simpleVariable:
  var.decl type .affect
  {
    debugYacc("Variable : "+ $1, AT);
    // TODO VariableHashed use at variable declaration (creation)
    VariableHashed v($1,$2); // @see if same thing if function parameters
    symbolTable.addElement(v);
    $$ = new Variable($1,$2,"local ",$3,false);
  }
// | names ARE type affect BACK_LINE
// 	{
//     /* TODO multiple variables declaration logic 1 */
// 		debugYacc("Variable declaration: "+ $1, AT);
// 	}
//     // TODO Handle SHARED
// | var.decl SHARED type affect BACK_LINE
// 	{
// 		VariableHashed v($1,$3);
// 		symbolTable.addElement(v);
// 		// $$ = new Variable($2,$4,$1,true);
// 	}
//     // TODO Handle SHARED
// | names ARE SHARED type BACK_LINE
// 	{
//     /* TODO multiple variables declaration logic 2 */
// 		debugYacc("  Variable des variables  avec portee "+ $1, AT);
// 	}
;

// TODO add scope and constancy to variable constructions
variable_construct:
  // ex: c is Maclasse
  var.decl NAME .affect BACK_LINE {
    // TODO ClassHashed use at class declaration (creation)
    VariableHashed classHashed($1,$2);
    symbolTable.addElement(classHashed);
    $$ = new Variable($1,$2,"local ",$3,false,false);
  }
  // c is MaClass(val1,va2)
| var.decl NAME arguments BACK_LINE {
    VariableHashed classHashed($1,$2);
    symbolTable.addElement(classHashed);
    $$ = new Variable($1,$2,$3,"local ",false,false);
  }
;

.scope:
  /* empty */
  { $$ = "local "; }
| LOCAL   { $$ = "local ";}
| GLOBAL  { $$ = "global ";}
;

// TODO use 'constancy' in declarations
// constancy:
//   /* empty */
//   { $$ = ""; }
// | CONST { $$ = "const"; }
// ;

var.decl:
  NAME IS { $$ = $1; }
;

containerAccess:
  NAME LEFT_BRACKET integerExpression RIGHT_BRACKET {
    $$ = new ArrayAccess($1, $3);
  }
;

/* ******************
 *    EXPRESSIONS   *
 * ******************/

.streamedExpressions:
  streamedExpressions.element {
    Operator* streamOperator= new Operator("<< ", $1);
    $$ = streamOperator;
  }
//   /* empty */
//   { $$ = new EmptyNode; }
| .streamedExpressions streamedExpressions.element {
    Operator* streamOperator= new Operator("<< ", $2);

    $1->addRightChild(streamOperator);
    $$ = $1;
  }
;

streamedExpressions.element:
  stringExpression  { $$ = $1; }
| runtimeValue      { $$ = $1; }
;

basicExpressions:
  basicExpression
| basicExpressions COMMA basicExpression {
    TranslatedNode* comma= new TranslatedNode(", ", $3);

    $1->addRightChild(comma);
    $$ = $1;
  }
;

basicExpression:
  string      { $$ = $1; }
| boolean     { $$ = $1; }
| varValue    { $$ = $1; }
| integer     { $$ = $1; }
| real        { $$ = $1; }
// @see if variable must be retrieved from name for type checking
;

// @see tranform TranslatedNode by Expression or subclass use ?
expression:
  LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {
    TranslatedNode* parenthExpr= new TranslatedNode("("+ $2->translate() +")");
    delete $2;
    $$ = parenthExpr;
  }
| stringExpressions {
    debug("expression from stringExpression", AT);
    $$ = $1;
  }
| conditionalExpression {
    debug("expression from conditionalExpression", AT);
    $$ = $1;
  }
| numericExpression {
    debug("expression from integerExpression", AT);
    $$ = $1;
  }
// | expression expression {
//     $1->addRightChild($2);
//     $$ = $1;
//   }
// | runtimeValue { $$ = $1; }
;

// @see There is no type checking :(
conditionalExpression:
  boolean { $$ = $1; }
// TODO handle parenthesis logic. Rework needs to be done on BooleanExpression class
| LEFT_PARENTHESIS conditionalExpression RIGHT_PARENTHESIS { $$ = $2; }
| conditionalExpression logicalOperator conditionalExpression {
    BooleanExpression* expr= new BooleanExpression($2,$1,$3);
    $$ = expr;
  }
| NOT conditionalExpression {
    debugYacc("Negation", AT);
    BooleanExpression* negation= new BooleanExpression(new Operator("!"), $2);
    $$ = negation;
  }
  // NAME should be boolean
// | NAME {
//     debugYacc("BooleanExpression from variable "+ $1, AT);
//     $$ = new BooleanExpression(new TranslatedNode($1));
//   }
// TODO add type checking on all of container accesses
// | containerAccess {
//     BooleanExpression* expr= new BooleanExpression($1);
//     $$ = expr;
//   }

| runtimeValue /* empty */
  {
    debugYacc("BooleanExpression from variable "+ $1->translate(), AT);
    $$ = new BooleanExpression($1);
  }
| stringExpression equalityOperator stringExpression {
    debugYacc("conditionalExpression by equality comparison", AT);
    BooleanExpression* comparison= new BooleanExpression($2,$1,$3);

    $$ = comparison;
  }
| numeric relationalOperator numeric {
    debugYacc("conditionalExpression by comparison", AT);
    BooleanExpression* comparison= new BooleanExpression($2,new BooleanExpression($1),new BooleanExpression($3));

    $$ = comparison;
  }
| LEFT_PARENTHESIS numericExpression RIGHT_PARENTHESIS relationalOperator numericExpression {
    debugYacc("conditionalExpression by comparison", AT);
    BooleanExpression* comparison= new BooleanExpression($4,$2,$5);

    $$ = comparison;
  }
;

// conditionalExpression.varValued:
// | runtimeValue relationalOperator numericExpression {
//     debugYacc("conditionalExpression by comparison", AT);
//     BooleanExpression* comparison= new BooleanExpression($2,$1,$3);

//     $$ = comparison;
//   }
// | runtimeValue arithmeticOperator numericExpression relationalOperator numericExpression {
//     debugYacc("conditionalExpression by comparison", AT);

//     $1->addRightChild($2);
//     $2->addRightChild($3);
//     BooleanExpression* comparison= new BooleanExpression($4,$1,$5);

//     $$ = comparison;
//   }
;

stringExpressions:
  string { $$ = $1; }
| stringExpressions stringExpression {
    debug("Concatenation of two string expressions", AT);
    $2->interpretAsString();
    Operator* concat = new Operator(" + ");

    $1->addRightChild(concat);
    concat->addRightChild($2);
    $$ = $1;
  }
| stringExpressions runtimeValue {
    debug("Concatenation of two string expressions", AT);
    $2->interpretAsString();
    Operator* concat = new Operator(" + ", $2);

    $1->addRightChild(concat);
    $$ = $1;
  }
;

// @see There is no type checking :(
stringExpression:
  string        { $$ = $1; }
| NUM_INTEGER   { $$ = new TranslatedNode("std::to_string("+ $1 + ")"); }
| NUM_REAL      { $$ = new TranslatedNode("std::to_string("+ $1 + ")"); }
;

numeric:
  number        { $$ = $1; }
| runtimeValue  { $$ = $1; }
;

number:
  real    { $$ = $1; }
| integer { $$ = $1; }
;

numericExpression:
  real { $$ = $1; }
| integerExpression { $$ = $1; }
  /* TODO check that there is no other operators */
| numericExpression arithmeticOperator numericExpression {
    debug("Operation between two numeric expressions", AT);

    $1->addRightChild($2);
    $2->addRightChild($3);
    $$ = $1;
  }
;

// @see There is no type checking :(
integerExpression:
  integer { $$ = $1; }
// @see if variable must be retrieved from name for type checking
| runtimeValue { $$ = $1; }
  /* TODO check that there is no other operators */
| integerExpression arithmeticOperator integerExpression {
    debug("Operation between two expressions", AT);

    $1->addRightChild($2);
    $2->addRightChild($3);
    $$ = $1;
  }
;

/* TODO single_expressions logic. What's the goal ? */
// single_expression:
//   PLUS single_expression { /* $$ = new Variable(); */ }
// | NOT single_expression { /* $$ = new Variable(); */ }
// | single_expression XOR single_expression { /* $$ = new Variable(); */ }
// | single_expression MOD single_expression { /* $$ = new Variable(); */ }
// | single_expression POW single_expression { /* $$ = new Variable(); */ }
// // | ABS single_expression { /* $$ = new Variable(); */ } // @see how to handle absolute
// | argument  { $$ = $1; }
// ;

/* ******************
 *  GENERIC SIMPLE  *
 * ******************/

// zero or some new lines
lineend:
  END_OF_FILE
| BACK_LINE /* Nothing to do */
;

begin:
  BACK_LINE         { }
| BEGINN BACK_LINE  { }
;

// @see can it just be a translated Node (variable name don't change) or a Node (Var or value)
// TODO affect logic
.affect:
  /* empty */
  { $$ = nullptr; }
| EQUALS expression {
    debug("Affectation value: "+ $2->translate(), AT);
    $$ = $2;
  }
// | EQUALS expression { $$ = $2; } // TODO use expression ?
// | EQUALS string   { $$ = $2; }
;

type:
  TYPE_INTEGER  { $$ = "int"; }
| TYPE_REAL     { $$ = "float"; }
| TYPE_STRING   { $$ = "std::string"; }
| TYPE_BOOLEAN  { $$ = "bool"; }
;

string:
  STRING  { $$ = new TranslatedNode($1); }
;

boolean:
  TRUE  { $$ = new BooleanValue(true); }
| FALSE { $$ = new BooleanValue(false); }
;

real:
// @see if variable must be retrieved from name for type checking
  NUM_REAL { $$ = new TranslatedNode($1); }
;

integer:
// @see if variable must be retrieved from name for type checking
  NUM_INTEGER { $$ = new TranslatedNode($1); }
;

varValue:
// @see if variable must be retrieved from name for type checking
  NAME { $$ = new TranslatedNode($1); }
;

/* ******************
 *    OPERATORS     *
 * ******************/

assignmentOperator:
  EQUALS { $$ = new Operator("="); }
| arithmeticOperator EQUALS {
    $1->setAsAffectation();
    $$ = $1;
  }
;

arithmeticOperator:
  PLUS    { $$ = new Operator("+"); }
| MINUS   { $$ = new Operator("-"); }
| MULT    { $$ = new Operator("*"); }
| DIVISE  { $$ = new Operator("/"); }
| MOD     { $$ = new Operator("%"); }
;

// NOT is a logical operator, but it is unary, not binary. Must be handle separatly
// @see if we use operator or TranslatedNode
logicalOperator:
  AND { $$ = new Operator("&&"); }
| OR { $$ = new Operator("||"); }
;

relationalOperator:
  LT  { $$ = new Operator("<"); }
| LE  { $$ = new Operator("<="); }
| GT  { $$ = new Operator(">"); }
| GE  { $$ = new Operator(">="); }
| equalityOperator { $$ = $1; }
;

equalityOperator:
  EQUALS EQUALS { $$ = new Operator("=="); }
| NE  { $$ = new Operator("!="); }
;

objectDotOperator:
  NAME SIMPLE_DOT { $$ = $1; }
  // TODO add dot operator on more complex structures ( "a.getPos().getX()" )
  // @see Define "object" rule ?
;

/* *********************
 * FACULATIVE END TAGS *
 * *********************/

endclass:
  lineend
| CLASS lineend {}
;

endfunction:
  lineend
| FUNCTION lineend {}
;

endprocedure:
  lineend
| PROCEDURE lineend {}
;

endif:
  lineend
| IF lineend {}
;

// endwhen:
//   lineend
// | WHEN lineend {}
// ;

// endcase:
//   lineend
// | CASE lineend {}
// ;

endwhile:
  lineend
| WHILE lineend {}
;

endfor:
  lineend
| FOR lineend {}
;

// endcode:
//   lineend
// | CODE lineend {}
// ;

enddestruct:
  lineend
| DESTRUCT lineend {}
;

endparameters:
  next_line
| PARAMETERS next_line {}
;


/* ************
 *    OTHER   *
 * ************/

//    -----------------------------REGEX METHODS-----------------------------------------
// function_regex:
//   NAME SIMPLE_DOT MATCH LEFT_PARENTHESIS strOrName RIGHT_PARENTHESIS { cout << "regular expression MATCH " << endl ;}
// | NAME SIMPLE_DOT SEARCH LEFT_PARENTHESIS strOrName COMMA strOrName RIGHT_PARENTHESIS { cout << "regular expression SEARCH " << endl ;}
// | NAME SIMPLE_DOT REPLACE LEFT_PARENTHESIS strOrName COMMA strOrName RIGHT_PARENTHESIS { cout << "regular expression REPLACE " << endl ;}
// ;

//    -----------------------------STRING METHODS----------------------------------------
function_string:
  objectDotOperator LENGTH LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("lENGTH() called \n"); }
| objectDotOperator TOUPPERCASE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("toUpperCase() called \n"); }
| objectDotOperator TOLOWERCASE LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("toLowerCase() called \n"); }
| objectDotOperator SUBSTRING LEFT_PARENTHESIS integerExpression RIGHT_PARENTHESIS { printf("SUBSTRING(int) called \n"); }
| objectDotOperator SUBSTRING LEFT_PARENTHESIS integerExpression COMMA integerExpression RIGHT_PARENTHESIS { printf("SUBSTRING(int,int) called \n"); }
| objectDotOperator SPLIT LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("SPLIT(\"str\") called \n"); }
| objectDotOperator STRIP LEFT_PARENTHESIS RIGHT_PARENTHESIS { printf("strip() called \n"); }
| objectDotOperator STRIP LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("strip(\"str\") called \n"); }
| objectDotOperator REPLACE LEFT_PARENTHESIS STRING COMMA STRING RIGHT_PARENTHESIS { printf("replace(\"str\",\"str\") called \n"); }
| objectDotOperator CONTAINS LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("contain(\"str\") called \n"); }
| objectDotOperator FIND LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("find(\"str\") called \n"); }
| objectDotOperator FINDFIRSTOF LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("findFirstOF(\"str\") called \n"); }
| objectDotOperator FINDLASTOF LEFT_PARENTHESIS STRING RIGHT_PARENTHESIS { printf("findFirstOF(\"str\") called \n"); }
;

/* ***************************
 *  containers declaration   *
 * ***************************/

//    -----------------------------array declaration-------------------------------------
array.decl:
  var.decl ARRAY LEFT_BRACKET { $$ = $1; }
;

array.type:
  RIGHT_BRACKET OF type { $$ = $3; }
;

// TODO handle scope for array
arrayDeclaration:
  /* scope */ array.decl NUM_INTEGER array.type
  {
    debugYacc("array declaration with size"+ $2, AT);
    // TODO check that size as a correct format (>0)
    $$ = new Array($1, $3, atoi($2.c_str()));
  }
| /* scope */ array.decl array.type container.affectation
  {
    debugYacc("array declaration with initializer list", AT);
    $$ = new Array($1, $2, $3);
  }
// | scope array.decl DOUBLE_DOT intOrName RIGHT_BRACKET array.type
//   { printf("array declaration with lower and upper bound\n"); }
;

//    --------------------------standard containers declaration--------------------------
stdContainerDeclaration:
  /* scope */ container.decl .container.affectation {
    if ($2 != nullptr) $1->setInitList($2);
    $$ = $1;
  }
;

container.decl:
  var.decl VECTOR .container.initSize OF type {
    debugYacc("vector declaration", AT);
    Vector* vector= new Vector($1, $5, $3);

    $$ = vector;
  }
| var.decl LIST .container.initSize OF type {
    debugYacc("list declaration", AT);
    List* list= new List($1, $5, $3);

    $$ = list;
  }
| var.decl MAP .container.initSize OF LT type COMMA type GT {
    debugYacc("map declaration", AT);
    Map* map= new Map($1, $6, $8, $3);

    $$ = map;
  }
| var.decl SET .container.initSize OF type {
    debugYacc("set declaration", AT);
    Set* set= new Set($1, $5, $3);

    $$ = set;
  }
;

.container.initSize:
/* empty */ { $$ = nullptr; }
| LEFT_BRACKET integerExpression RIGHT_BRACKET { $$ = $2; }
;

container.affectation:
  EQUALS LEFT_ACCOLADE basicExpressions RIGHT_ACCOLADE { $$ = $3; }
;

.container.affectation:
/* empty */ { $$ = nullptr; }
| container.affectation { $$ = $1; }
;


%%

void yyerror(const std::string& mess){
    std::cerr << "Error found at line " << yylineno << " :  "<< mess << std::endl;
    existing_parsing_error= true;
}

void yyprint(const std::string& msg){
    std::cout << "[l" << yylineno << "] "<< msg<< std::endl;
}
